# 3.1 리액트의 모든 훅 파헤치기

- 훅은 클래스형 컴포넌트에서만 가능했던 state, ref 등 핵심적인 기능을 함수형에서도 가능하게 만듦
- ⭐useState
  - 함수형 컴포넌트내부에서 상태를 정의하고 관리할 수 있게 해주는 훅이다.
  - 리액트에서 렌더링은 함수형 컴포넌트의 return함수를 실행해 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트된다.
  - useState는 결괏값을 어떻게 함수가 실행돼도 그 값을 유지할까?
  - useState 내부에 선언된 함수(setState)가 함수의 실행이 종료된 이후에도 지역변수인 state를 계속 참조하는 **클로저 형태**로 구현되어 있다.
  ### 게으른 초기화
  ```jsx
  // 일반적인 사용 : 바로 값을 집어넣음
  const [count, setCount] = useState(Number.parseInt(window.localStorage.getItem(key)));

  // 게으른 초기화 : 함수를 실행해 값을 반환한다
  const [count, setCount] = useState(() => Number.parseInt(window.localStorage.getItem(key)));
  ```
  - 초기값을 넣는 대신에 특정 값을 넘기는 함수를 인수로 넣는 경우를 말한다.
  - useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 리액트 공식문서에서 말한다.
  - 이 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다.
    - 그냥 쓰게 된다면 리렌더링시에도 계속해서 해당 접근을 하기 때문에 낭비가 발생한다.
  - 렌더링이 실행될 때마다 함수형컴포넌트의 함수가 다시 실행된다.
    - useState의 값도 마찬가지이다.
    - 그렇지만 useState의 넣은 초기값은 최초 렌더링 이후에는 실행되지 않는다.
  - 언제 사용하는가?
    1. 브라우저 저장소에 접근할 때
    2. map, filter같은 배열에 대한 접근
    3. 초기값 계산을 위해 함수 호출이 필요할 때.
- ⭐useEffect
  - 클래스 컴포넌트의 생명주기 함수를 대체하기 위해 나온 훅이 아니다.
  - 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수효과를 만드는 메커니즘이다.
    - 이 부수효과가 “언제” 일어나는지 보다 어떤 상태값과 함께 실행되는 지가 중요하다
  > 렌더링될 때마다 의존성 배열에 있는 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 평범한 함수이다.
  ### 클린 업 함수
  - useEffect 내에서 반환되는 함수
  - 주로 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.
  ```jsx
  useEffect(() => {
    window.addEventListener();
    return () => {
      console.log('클린업 함수 실행');
      window.removeEventListener();
    };
  }, []);
  ```
  - 클린업 함수는 이전 state를 참조해 실행된다.
    - 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행한다.
  - **클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해주는 개념으로 보는 것이 옳다.**
  ### 의문점
  > Q. 의존성 배열이 없는 useEffect가 매렌더링마다 실행된다면 그냥 useEffect 없이 써도 되는게 아닐까?
  > A. useEffect는 클라이언트 사이드에서 실행되는 것을 보장해준다. 그래서 window 객체에 접근하는 코드를 사용할 수 있음.
  A. **useEffect는 컴포넌트가 렌더링이 완료된 이후에 실행된다, 반면 직접 실행은 렌더링되는 도중에 실행되기 때문에 서버에서도 실행되기 때문에 성능에 악영향을 끼친다.**
  >
  ### 의존성 배열
  - `Object.is`를 사용한 얕은 비교를 한다
    - 객체는 판단하지 못함.
  ### useEffect 사용시 주의점
  1. 의존성 배열에 포함되지 않은 값을 넣으라는 경고문을 안보이게 하지마라.
     - 대부분 최초에만 로직이 동작하게끔 빈배열로 두는데 이것은 state나 props와 실제 변경 사이에 연결고리가 끊어져 있는 것이다.
     - 정말로 빈배열이 필요하다면 **컴포넌트의 상태와 해당 로직이 별개로 작동해야하는지** 혹은 **여기서 호출하는 것이 최선인지** 한번더 검토해야 한다
  2. useEffect의 1번째 인자는 이름이 있는 함수를 넣어라.
     - 리액트 공식문서에서도 익명함수를 사용하지만 이름을 붙인다면 해당 useEffect의 목적을 파악하기 훨씬 쉬워진다.
  3. 거대한 useEffect를 만들지마라
     - useEffect의 크기가 커질수록 앱성능에 악영향을 미친다.
     - 의존성 배열이 늘어날 것 같다면 여러개의 useEffect로 분리하는 것이 좋다
  4. 불필요한 외부함수를 만들지 마라
     - useEffect 내부에서 함수를 만들면 의존성 배열도 최소화할 수 있고 해당 함수를 useCallback하지않아도 된다.
     - 즉, **useEffect 내에서 사용할 부수효과라면 useEffect 내부에서 정의해서 사용하는 편이 도움된다.**
- useMemo
  > 비용이 큰 연상에 대한 결과를 저장해두고 저장된 값을 반환하는 훅
  - 의존성 배열의 값이 변경되면 함수를 재실행한다.
  - 값 뿐만 아니라 컴포넌트도 가능하다.
    - 이러면 React.memo랑 다른게 뭐지…
    - 물론 React.memo를 쓰는게 현명하다고 함.
    - [ ] 읽어보자 : https://ui.toast.com/weekly-pick/ko_20190731
  ```jsx
  const MemoComponent = useMemo(() => <Component value={value} />, [value]);

  return { MemoComponent };
  ```
  비용이 많이 드는 연산은 뭘까? ⇒ 리렌더링하는 연산이 더 비용이 많이 드니까 메모이제이션 하는게 낫다고 저자는 말했음.
- useCallback
  > 인수로 넘겨받은 콜백 자체를 기억한다.
  - 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미.
- useRef
  - 변경 가능한 상태값을 저장한다.
  `useState`와 다른점.
  1. useRef는 반환값인 객체 내부에 있는 current로 값에 접근과 변경할 수 있다.
  2. **useRef는 값이 변하더라도 재렌더링을 일으키지 않는다.**
  ### 어떨 때 사용할까?
  - 함수 외부에서 값을 선언하는 것도 같은 효과가 있지만 이건 메모리를 계속 차지하는 단점이 있다.
  - 컴포넌트가 렌더링될 때만 생성되며 각 컴포넌트 인스턴스가 여러개여도 각각 별개의 값을 바라본다.
  - 주로 DOM에 접근하고싶을때 사용한다.
  - 렌더링을 발생시키지 않고 상태값을 저장할 수 있다는 특징 때문에 useState의 이전 값을 저장하는 usePrevious같은 훅을 구현할 때 사용한다.
  ### 내부 구현
  - useMemo를 사용해서 객체로 구현함
  ```jsx
  export function useRef(initValue) {
    currentHook = 5;
    return useMemo(() => ({ current: initValue }), []);
  }
  ```
- useContext
  ### context란
  - props 내려주기를 극복하기 위해 등장한 개념
  - props 전달 없이도 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값을 사용할 수 있다.
  - context가 미치는 영역은 최대한 좁게 만들어야 한다.
  > 이거 쓸빠엔 그냥 전역상태 라이브러리 쓸 거임.
- useReducer
  - useState의 심화버전
  - 사전에 정의된 dispatcher로만 수정할 수 잇게 만들어 둠.
  - 즉, state를 변경하는 시나리오를 제한적으로 두는 용도.
  - 그냥 redux 같음.
    - redux는 전역상태로 공유도 가능하니까 굳이 이걸 쓸 필요는 없을 거같음
- useImperativeHandle
  > 부모 컴포넌트에게 받은 ref를 원하는 대로 수정할 수 있는 훅이다.
  - 잘사용되진 않지만 특정 사례에서는 유용하게 활용된다.
  - 먼저 `React.forwardRef`를 알아야 한다.
  ### React.forwardRef
  - ref는 주로 HtmlElement에 접근하는 용도로 사용된다.
  - ref를 상위 컴포넌트에서 하위 컴포넌트로 전달하고 싶을 때 사용한다.
    - ref는 예약어라서 props로 사용되지 못하기 때문이다.
  - 탄생이유 : ref를 전달하는데 일관성을 제공하기 위함.
  - 사용방법
    - 컴포넌트를 `forwardRef`로 감싸고 2번째 인수에 ref를 전달한다.
  ***
- useLayoutEffect
  - useEffect와 동일하지만 모든 DOM 변경 후에 useLayoutEffect의 **콜백함수 실행이 동기적으로 발생한다.**
  ### 실행순서
  1. 리액트가 DOM을 업데이트
  2. **useLayoutEffect 실행**
  3. 브라우저에 변경 사항을 반영
  4. **useEffect 실행**
  ***
  - **useLayoutEffect는 브라우저에 변경 사항이 반영되기 전에 실행됨**
  - **useEffect는 브라우저에 변경 사항이 반영된 이후에 실행됨**
  ### 동기적으로 발생한다는 것
  - 리액트는 **useLayoutEffect**의 실행이 종료될 때까지 기다린 다음에 화면을 그린다는 것이다.
    - 따라서 이러한 작동방식은 성능에 문제가 발생할 수 있다.
  ### 언제 사용하면 좋을 까?
  - DOM은 계산 됐지만 이것이 화면에 반영되기 전에 하고싶은 작업이 있을 때와 같이 반드시 필요할 때만 사용하는 것이 좋다.,
    1. 특정 요소에 따라 DOM 요소를 기반으로 한 애니메이션
    2. 스크롤 위치를 제어하는 것
- useDebugValue
  - 프로덕션 웹서비스에서 사용하는 훅은 아니다.
  - 디버깅 하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다.
  - 다른 함수에서만 사용할 수 있기때문에 분리해줘야 한다.

## 훅의 규칙

1. 최상위에서만 훅을 호출해야한다
   - 반복문, 조건문, 중첩함수 등에서 훅을 실행할 수 없다.
   - 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
2. 훅을 호출할 수 있는 것은 리액트 함수형 컴포넌트, 사용자 정의 훅. 2가지 뿐이다.

## 사용자 정의 훅(Custom Hook)

- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용하는 것.
- use로 시작해야한다는 규칙이 있음.
- useState와 useEffect로 주로 구성함.
- return 할때 컴포넌트가 아닌 state를 반환하면 됨.

## 고차 컴포넌트(HOC : Higher Order Component)

- 리액트가 아니더라도 js 환경에서 널리 쓰일 수 있다.
- 리액트에서 유명한 고차 컴포넌트는 `React.memo`이다.
- 주로 사용하는 경우는 부모가 렌더링된다면 자식도 렌더링되는 상황을 막기 위함이다.
- 고차 함수의 정의 : 함수를 인수로 받거나 결과로 반환하는 함수
  - 주로 배열의 내장함수인 map이 있다.

> 얘기하고 싶은 것

207쪽. useEffect사용할 때 즉시실행함수로 넣는 것은 이름이 없어서 판단하기 어렵지 않나 라는 생각

- [ ] useLayoutEffect에서 화면에 반영되기 전에 하고싶은 작업이 있을 때와 같이 반드시 필요할 때가 언제일까? → api를 먼저 가져오는 용도로 사용할 수는 없을까? useEffect를 사용해서 가져오는 경우가 있는데 이때 2번 되는 그런 경우가 있었던 것 같은데 이걸 쓰면 괜찮을까 싶음
- [ ] 추가로 나는 useQuery를 사용할 때 최적화 하기 위해서 enable : false로 설정하고 useEffect로 첫 렌더링 시에 refatch로 가져오는 방법을 사용했다.
