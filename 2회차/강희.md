### useState 
- 함수형 컴포넌트 내부에서 상태를 정의하고, 관리할 수 있게 해주는 훅
- 클로저에 의존해 구현돼 있을 것이라 짐작함

#### useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라 한다
- 초기값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
- ex) `localStorege`, `sessionStorage`에 대한 접근, `map`, `filter`, `find` 같은 배열에 대한 접근
``` js
// 일반적인 useState
// 바로 값을 집어넣는다.
const [count, setCount] = useState(Number.parseInt(window.localStorage.getItem(cacheKey)))

// 게으른 초기화
// 위 코드와 차이점은 함수를 실행해 값을 반환한다
const [count, setCount] = useState(()=>Number.parseInt(window.localStorage.getItem(cacheKey)))

```

### useEffect
- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다
- 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과 실행
- state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수
- `클린업 함수`
  - 이벤트를 등록하고 지울 때 사용 된다
  - 새로운 값과 함께 렌더링된 뒤에 실행된다
  - 이전 상태를 청소해 주는 개념
- `의존성 배열`이 없는 useEffect는 랜더링 마다 실행된다 
- 클라이언트 사이드에서 실행되는 것을 보장, window 객체 접근가능
- 렌더링 완료된 이후 실행된다
- 컴포넌트가 렌더링된 후에 부수 효과를 일으키고 싶을 때 사용하는 훅
### useEffect 주의점?
- useEffect의 첫 번째 인수에 함수명을 부여하라
- 거대한 useEffect를 만들지 마라
- 불필요한 외부 함수를 만들지 마라

### useMemo
- 의존성 배열이 변경되지 않았으면 함수를 재실행 하지 않고 이전에 기억 해둔 값 반환
### useCallback
- 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미
### useRef
- 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- 값이 변하더라도 렌더링을 발생시키지 않는다
### useContext
- 상태를 주입할 뿐 그이상의 기능도, 그 이하의 기능도 하지 않는다
### useReducer
- 반환값은 길이가 2인 배열이다
- 3개의 인수를 필요로 한다 (reducer, initialState, init)
  1. action 함수
  2. 초깃값
  3. 초깃값을 지연해서 생성시키고 싶을때 사용 (게으른 초기화가 일어남) **필수값X
### useImperativeHandle
- 부모에게서 넘겨받은 ref를 원하는 대로 수정 할 수 있는 훅
### useLayoutEffect
- useEffect와 시그니처가 똑같다 (하는일이 같다)
- 모든 DOM의 변경 후 동기적으로 발생한다
- 실행순서
  1. 리액트가 DOM을 업데이트
  2. useLayoutEffect 실행
  3. 브라우저에 변경 사항 반영
  4. useEffect 실행
- DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용
- ex) dom 기반 애니메이션, 스크롤 위치
### useDebugValue
- 디버깅용 훅

## 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 사용자 정의 훅 (nuxt3의 composables 과 비슷한거 같다)
- **동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 취하게 하고 싶다면 사용자 정의 훅 사용**
- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용
- use 로 시작하는 이름 사용
 
### 고차 컴포넌트 (HOC : Higher Order Component)
- **렌더링의 결과물에 영향을 미치는 공통 로직이라면 고차 컴포넌트사용**
- 컴포넌트 자체의 로직을 재사용하기 위한 방법
- 리액트가 아니여도 사용 가능
- 고차 함수의 일종이다
  - 고차함수 : 함수를 인수로 받거나 결과로 반환하는 함수
  - ex) `map`, `forEach`, `reduce` 등
- with로 시작하는 이름 사용
- 주의점
  1. 부수 효과 최소화ㄴ
  2. 여러개의 고차 컴포넌트 감쌀 경우 복잡성이 커진다

<!-- ## 3-1 궁금한거
1. 게으른 초기화 사용 사례? 복잡한 연산은 어떤게 있을까?
2. useReducer 실 사용 예? 상세페이지 create edit 부분에 사용할려나..?
3. 고차 컴포넌트는 로그인 관련 로직에서 자주 사용되려나..? -->
