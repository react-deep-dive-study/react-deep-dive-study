### 1.1 : 자바스크립트의 동등 비교

리액트의 리렌더링이 일어나는 이유, (feat. 의존성 배열)

- props의 동등 비교에 따른 결과.
  - props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄진다
  - 얕은 비교 = 주소값을 비교한다는 것.
- 이 얕은 비교가 react에서 어떻게 동작하는 지 이해하지 못한다면 렌더링 최적화에 어려움을 겪을 것이다.

### 동등 비교를 기반으로하는 작업들

- 가상 DOM과 실제 DOM의 비교
- 리액트 컴포넌트가 렌더링할지를 판단하는 방법
- 변수나 함수의 메모이제이션

### 동등비교의 동작원리

- **사전 지식**

  - 원시 타입과 객체 타입의 **값을 저장하는 방식의 차이**
  - `원시타입` : 실제 값을 저장한다
  - `객체타입` : 참조 값을 저장한다.
    - 동일한 값을 저장해도 저장된 메모리 위치가 다르기 때문에 다른 값이다.
  - `object.is`

    - ES6에 추가된 비교 문법
    - ==와 ===보다 좀더 개발자가 기대하는 방식으로 정확히 비교한다.
      - 하지만 객체 비교에서는 소용이 없다.

    ```jsx
    -0 === +0; // true
    Object.is(-0, +0); // false

    Number.NaN === NaN; // false
    Object.is(Number.NaN, NaN); // true

    NaN === 0 / 0; // false
    Object.is(NaN, 0 / 0); // true
    ```

  - 얕은 비교 : 기본 타입의 경우 값을 비교, 객체의 경우 주소값을 비교
  - 깊은 비교 : 객체의 경우에도 값을 비교한다.

### React에서의 동등 비교

- 내부적으로 ==와 ===이 아닌 `object.is`를 사용한다.
- objectIs를 기반으로 `shallowEqual`이라는 함수를 만들어 의존성 비교, 동등 비교에 사용한다.
- `shallowEqual`

  - 주어진 객체의 키를 순회하면서 엄격한 동등성을 가지는 지 확인하고 다른 값이 있다면 false를 반환하고 두 객체의 모든 키의 값이 동일하다면 true를 반환한다.
  - 단순히 `Object.is`를 수행하는 것이 아니라 객체 간의 비교도 추가돼 있다.
  - 두 객체의 key와 key value를 비교하며 Object.is에서 수행하지 못한 객체 간 얕은 비교를 한번 더 수행한다
    - 객체 간 얕은 비교란 객체의 1번째 깊이에 존재하는 값만 비교한다는 것이다.

  ```jsx
  // 참조값이 다르기 때문에 false를 반환한다
  Object.is({ hello: 'world' }, { hello: 'world' }); // false

  // 객체의 1depth까지는 비교가 가능하다.
  shallowEqual({ hello: 'world' }, { hello: 'world' }); // true

  // 그러나 2 depth까지 가면 비교할 방법이 없어서 false를 반환한다.
  shallowEqual({ hello: { hi: 'world' } }, { hello: { hi: 'world' } }); // false
  ```

  - [x] 이렇게 객체의 얕은 비교까지만 구현한 이유가 뭘까? ⇒ 성능 상의 이슈
    - 1depth까지는 그래도 깊은 비교를 한 것인데 그 이후는 왜 `lodash 라이브러리의 isEqual()`나 `JSON.stringify()`를 사용하지 않은 것일까?
  - react에서 props는 객체다
    - 일반적인 케이스라면 얕은 비교로도 충분할 것이다 하지만, **props에 객체를 넘겨준다면** 예상치 못하게 동작한다.
    - React.memo를 사용해 컴포넌트를 메모이제이션해줘도 효과가 없다는 것이다.
  - 내부의 객체까지 완벽하게 비교하기 위한 재귀문까지 넣었다면 객체가 몇개가 있을지 알 수 없으니 비교하려고 한다면 성능에 악영향을 줬을 것이다.

> 느낀 점

- props로 전달 할 때는 객체는 전달하지 말고 1depth로 이뤄진 값들을 전달하자,
  왜냐하면 props자체가 객체라서 해당 객체의 1 depth까지 비교하는 것은 react에서 구현했지 만 2depth는 성능상의 이유로 구현하지 않았기 때문.
  >

### props 자체가 객체라서 객체의 1 depth까지 비교하는 것은 react에서 `shallowEqual`로 구현하였고 더 깊은 depth는 비교하지 못하여 false를 반환한다.

### 공부하고 싶은 것

- useMemo와 useCallback의 필요성과 동작 원리

# 2장

### 컴포넌트명

```jsx
<foo:bar /> // 2개 이상은 안된다.

.로 이어주는 것이 가능하다 여러개도 가능함
<foo.bar.baz /> // 단, :와 함께 사용할 수 없다.
```

### jsx → js 트랜스파일될 때 React.createElement를 사용한다는 것

### 가상 DOM과 리액트 파이버

# 리액트 파이버

- 가상 DOM과 렌더링 과정을 최적화하게 해주는 것.
- 리액트에서 관리하는 평범한 js 객체이다.
- 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것.
- 처리하는 내용이 많아서 메모리 상에서 먼저 수행되고 최종 결과물만 실제 DOM에 적용한다.
- 가상 DOM과 실제 DOM의 변경사항을 수집하여 차이가 있다면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.
- 리액트 파이버의 목표 : 웹 앱에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결 하는 것이다.

## 하는 일

- 작업을 작은 단위로 분할하고 쪼갠다음, 우선순위를 매긴다.
- 이러한 작업을 일시중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.
- 모든 작업들은 비동기로 일어난다.

## 파이버 구현 내용

- 하나의 작업 단위로 구성됨.
- 리액트는 작업 단위를 하나씩 처리하고 `finishWork()`라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경사항을 만들어 낸다.
  **실제 단계**
  1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
  2. 커밋 단계에서는 DOM에 실제 변경사항을 반영하기 위한 작업, `commitWork()`가 실행되는데 동기식으로 일어나고 중단될 수도 없다.

### 리액트 요소와 파이버의 차이점

- 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 최초로 마운트되는 시점에 생성되어 **재사용**된다.

---

파이버는 state가 변경되거나 생명주기 메소드가 실행되거나 DOM의 변경이 필요한 시점등에 실행된다.

### 파이버 트리

2가지가 존재한다.

1. 현재 모습을 담은 파이버 트리
2. 작업 중인 상태를 나타내는 workInProgress트리

- 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 변경해야한다.
- 이러한 기술을 **더블 버퍼링**이라고 한다.
  - 리액트에서 나온 기술은 아니고 컴퓨터 그래픽 분야에서 사용하는 용어이다.
  - 그 다음에 그려야 할 그림을 미리 그린다음에 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 말한다.

## 파이버의 작업 순서

1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하는데 더 이상 자식이 없는 파이버를 만날때까지 트리형식으로 실행된다.
2. 1번 작업이 완료되면 `ciomplieteWork()`함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.
   - return은 부모 요소를 말한다.
5. 루트 노드가 완성되는 순간 최종적으로 `commitWork()`가 수행되고 이 중 변경사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다.

---

이벤트 핸들러에 함수를 등록할 때 화살표 함수로 생성하는 것은 좋지 않다.

- 렌더링을 할 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화 수행하기 어렵다.

```jsx
<button onClick={()=>{ ... }}> 클릭 </button>
```

### 클래스형 컴포넌트의 한계

1. 데이터의 흐름을 추적하기 어렵다
2. 앱 내부 로직의 재사용이 어렵다
3. 기능이 많아질 수록 컴포넌트의 크기가 커진다
4. 함수형 컴포넌트보다 상대적으로 어렵다
5. 코드 크기를 최적화하기 어렵다
6. 핫리로딩이 불리하다.

---

### useEffect는 생명주기를 위한 훅이 아니다.

비슷할 뿐이지 똑같다는 것은 아니다.

### 클래스형 컴포넌트의 장점

- 생명주기 함수
- 자식 컴포넌트에서 발생한 에러에 대한 처리는 클래스형 컴포넌트에서만 가능함.

# 리액트의 렌더링

- 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.
- 리액트의 렌더링은 동기적으로 작동하기 때문에 렌더링 과정이 길어진다면 앱의 성능 저하로 이어지고 결과 적으로 그 시간만큼 브라우저의 다른 작업이 지연된다.

## 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링
2. 리렌더링
   - 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.
   - state 변경시, props 변경시, 부모 컴포넌트가 렌더링되는 경우 자식도 무조건 리렌더링 됨

## 리액트에서 key

- 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일 한 요소를 식별하는 값이다.

## 렌더와 커밋

- 리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 2단계로 분리되어 실행된다.

### 렌더 단계

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.
- 즉, 렌더링 프로세스에서 컴포넌트를 실행해 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계이다.
  - 여기서 비교하는 것은 크게 type, props, key이다.

### 커밋 단계

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.
  - 이 단계가 끝나야 브라우저의 렌더링이 발생한다.

**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.**

- 리액트 렌더링을 수행했으나 커밋 단계까지 갈필요가 없다면 이 커밋 단계는 생략이 된다.
- 즉, 리액트 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다.
- 렌더링 과정 중 1단계인 렌더 단계에서 변경사항을 감지할 수 없다면 커밋 단계를 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

## 메모이제이션

렌더링 비용과 메모이제이션 비용 중 어떤게 더 비싼 걸까?

메모이제이션 비용

- 값을 비교하고 렌더링이나 재계산이 필요한지 판단하는 작업
- 결과물을 저장하고 다시꺼내와야하는 비용

메모이제이션은 하지 않는 것보다 했을 때 더 많은 이점을 누릴 수 있다.

최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

---

객체 내부의 값은 같지만 참조가 변경되기때문에 다시렌더링하는 과정에서 해당 객체들도 모조리 다시 생성하기 때문
