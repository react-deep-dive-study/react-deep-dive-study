### 싱글 페이지 애플리케이션 (SPA)

<aside>
💡 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 **브라우저의 자바스크립트에 의존하는 방식**을 의미한다.

</aside>

### 정의

- SSR과 반대되는 개념
- 최초에 첫 page에서 data를 모두 불러온 후 페이지 전환을 위한 모든 작업이 JS와 브라우저의 `history.pushState`와 `history.replaceState`로 이뤄지기 때문에 페이지를 불러온 이후에 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리하므로 싱글 페이지 애플리케이션이라고 한다.

### 특징

1. body에 아무런 내용이 없다.
   - **이유**
     1. **body 내부의 내용은 JS로 삽입한 이후에 렌더링** 하기 때문.
        - 그 결과 DOM을 추가, 수정, 삭제하는 방식으로 페이지가 전환된다.
     2. 페이지 전환시에도 새로운 HTML 페이지를 요청하는 것이 아니라 JS에서 다음 페이지의 **렌더링에 필요한 data만 HTTP 요청을 통해서 가져오기** 때문이다.
2. 최초에 로딩해야할 JS 리소스가 커지는 단점이 있다.
   - 그러나, 그 이후에는 필요한 리소스를 받아올 일이 적기 때문에 사용자에게 좋은 UX/UI를 제공한다.
     - 필요한 일부 영역만 다시 그리기 때문.

### JAM 스택

- 기존의 웹 개발은 LAMP 스택이었다.
  - 리눅스, 아파치, My SQL, PHP/Python
  - 운영체제,서버,데이터베이스,웹 프레임워크
- JavaScript, API, Markup
- 나는 추가로… 배포(Ubuntu), 웹 디자인
- 급 궁금
  나는 이렇게 기술 스택(?)을 사용하는 것 같은데 다른 분들은 어떤 스택이 있으실지
  1. figma
  2. ubuntu
     - 쉘스크립트
  3. nginx
  4. docker
  5. 피들러
  6. 디비버
  ***
  - jest,

---

- js파싱을 위해서 CPU를 소비하는 시간이 눈에 띄게 증가했다는 것
  - 모바일에서 상호작용까지 평균 대기 시간은 12초, 모든 컨텐츠 로딩에 걸리는 시간은 18초
- 사용자의 기기와 인터넷 속도는 크게 개선되었지만 실제 사용자들이 느끼는 웹 앱의 로딩 속도는 5년 전이나 지금이나 크게 차이가 없거나 느리다는 것.

### 서버 사이드 렌더링 (SSR)

<aside>
💡 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식

</aside>

### 정의

- 렌더링에 필요한 모든 작업을 서버에서 수행한다.
- 웹페이지가 점점 느려지는 상황을 개선하고자 서버에서 페이지를 렌더링해 제공하는 기존의 웹 개발 방식이 떠오르고 있는 추세다.

> **Q. SPA와 SSR의 차이점**

A. 웹페이지 렌더링의 책임을 어디에 두느냐가 관건.

>

### 장점

1. **최초 페이지 진입이 비교적 빠르다.**
   - 화면 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 SSR이 더 빠를 수 있다.
2. **검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.**
   - SEO에 유용하다 (feat. **검색엔진이 크롤링하는 과정**)
     1. 검색 엔진 로봇이 페이지에 진입한다.
     2. 페이지가 HTML 정보를 제공해 로봇이 HTML을 다운로드 한다
        - 다운로드만 하고 JS를 실행하지는 않는다.
     3. 다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 이를 바탕으로 검색엔진에 저장한다.
   - Q. **검색엔진의 방문과 사용자의 브라우저 방문의 차이점**
     A. 내부에 있는 JS 코드의 실행 여부.
     - 검색엔진은 페이지의 정적 정보를 가져오는 것이 목표이기 때문에 JS를 다운로드 하거나 실행할 필요가 없다.
     - 그러나 SPA는 JS에 의존하기 때문에 특정 조치를 취하지 않는다면 불이익이 있다.
3. **누적 레이아웃 이동이 적다.**
   - `CLS` : 누적 레이아웃 이동
     - 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 화면이 덜컥 거리는 부정적인UX 를 말한다.
     - 즉 사용자가 예상치 못한 시점에 페이지가 변경되는 불편을 말한다.
   - SSR은 이러한 요청이 완전히 완료된 페이지를 제공하기 때문에 이러한 문제에서 자유롭다.
4. **사용자의 디바이스 성능에 비교적 자유롭다.**
   - JS 리소스의 실행은 사용자의 디바이스에서만 실행되므로 절대적으로 사용자 디바이스 성능에 의존적이다.
   - SSR은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능하다.
5. **보안에 좀더 안전하다**
   - 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다.

### 단점

1. 소스코드를 작성할 때 **항상 서버를 고려해야 한다.**
   - 서버에서 실행된다면 window나 브라우저 저장소에 접근하는 코드를 최소화해야하고 서버에서 실행되지 않도록 처리해야한다.
2. **적절한 서버가 구축**돼 있어야 한다.
   - 사용자 요청을 적절히 대응할 수 있는 물리적인 가용량을 확보해야 함.
   - 예기치 않은 버그에 대응할 수 있는 복구 전략도 필요 함
   - 요청 분산과, PM2 같은 프로세스 매니저의 도움도 필요하다
3. **서비스 지연에 따른 문제**
   - SPA는 느린 작업에 로딩중 처럼 적절한 표시를 할수 있지만
   - SSR은 어떠한 정보도 제공할 수 없다. 그래서 더 안 좋은 UX를 제공할 수 있다.

---

### 결론

SSR이 무조건 좋은 것이 아니라 웹페지의 설계와 목적에 따라서 알잘딱으로 구현해야 한다.

### SSR을 위한 React API

- 브라우저의 window 환경이 아닌 Node.js같은 서버 환경에서 실행할 수 있으며 window 환경에서 실행시 에러가 발생할 수 있다.
- renderToString
  > 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
  - 클라이언트에서 실행되는 js 코드를 포함하거나 렌더링하는 역할을 해주지는 않는다.
    - 필요한 js코드는 별도로 제공해줘야 함.
  - 단순히 최초 HTML 페이지를 빠르게 그려주는 목적이 있을 뿐이지 사용자와 인터렉션할 준비가 되었다는 것은 아니다.
- renderToStaticMarkup
  - renderToString와 동일하지만 data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM요소를 만들지 않는다는 이점이 있으며 아주 약간의 크기를 줄일 수 있다.
  - 해당 함수로 생성된 결과물은 순수한 HTML만을 만들 때 사용되기 때문에 이벤트 핸들러를 붙일 수 없다.
    - 그래서 정적인 내용을 가진 경우에만 필요하다.
- renderToNodeStream
  - renderToString와 결과물이 완전히 동일하지만 2가지 차이점이 있다.
    차이점 1.
  - renderToNodeStream는 Node.js에 의존하고 있으며 브라우저에서 사용하는 것이 불가능하다.
    차이점 2.
  - 결과물의 타입
    - renderToString : string
    - renderToNodeStream : Node.js의 ReadableStream
      - ReadableStream은 utf-8로 인코딩된 바이트 스트림으로 Node.js에서만 사용할 수 있다.
      - 그래서 브라우저가 원하는 결과물 string을 얻기 위해선 추가적인 작업을 해야한다.
      - ReadableStream 자체는 브라우저에서 사용할 수 있는 객체이지만 만드는 과정이 브라우저에서 불가능하게 되어 있다.
  - ReadableStream은 왜 필요할까?
    - 스트림은 큰 데이터를 다룰 때 작은단위(청크)로 분할해 조금씩 가져오는 방식을 의미한다.
    - 즉, HTML요소가 매우 크다면 청크 단위로 분리해 순차적으로 처리해 서버에 부담을 줄일 수 있다.
  - 대부분의 널리 알려진 리액트 SSR 프레임워크는 대부분 renderToString 대신에 renderToNodeStream를 채택하고 있다.
- renderToStaticNodeStream
  - renderToString의 renderToStaticMarkup처럼 renderToNodeStream의 같은 역할을 한다.
  - 즉, hydrate할 필요가 없는 순수 HTML 결과물을 필요로 할 때 사용한다
- hydrate
  - renderToString과 renderToNodeStream에서 생성된 HTML 컨텐츠에 js 핸들러나 이벤트를 붙이는 역할을 한다.
  - render와 비슷하지만 다르다.
  ### reder와의 차이점
  `hydrate`는 이미 렌더링된 HTML이 있다는 가정하에 수행이 되고 이미 있는 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다는 것이다.
  - 만약 리액트와 관계없는 정적 HTML 요소로 만들어진 정보를 넣어주면 어떻게 될까?
    - 경고 문구가 출력된다.
  - `hydrate`는 단순히 이벤트나 핸들러를 추가하는 것 이외에도 렌더링을 한번 더 수행하면서 `hydrate`가 수행한 렌더링 결과물 HTML과 인수로 넘겨받은 HTML을 비교하는 작업을 수행하기 때문이다.
  - 여기서 발생한 불일치가 바로 에러의 원인이며 불일치가 발생하면 `hydrate`이 렌더링한 기준으로 웹페이즈를 그리게 된다.
    - 이렇게라도 렌더링되는 것은 올바른 사용법이 아니다 사실상 서버와 클라이언트에서 2번 렌더링 하게 되고 결국 SSR의 장점을 포기하는 것이기 때문에 반드시 고쳐야 한다.
  - 불가피하게 불일치가 발생할 수 있는 경우에는 해당 요소에 suppressHydrationWarning을 추가해 경고를 끌 수 있지만 필요한 곳에 제한적으로 사용해야 한다.

### Next.js 톺아보기

### 특징

- 디렉터리 기반 라우팅
- 예약어로 지정된 파일명이 있다.

---

- Link 태그 장점
  - a태그를 사용하면 페이지를 만드는데 필요한 모든 리소스를 처음부터 다 가져온다 그러나 Link 태그는 서버 사이드 렌더링이 아닌 클라이언트 라우팅, 렌더링 방식으로 작동하기 때문에 SSR의 장점과 SPA의 장점을 모두 살릴 수 있다.
  - 앱을 처음부터 다시 서버에서 불러와야 하는 정말 드문 케이스 외에는 Next.js에서 제공하는 라우터를 사용해 페이지를 이동시키는 것이 좋다.
