# 5장

### 할얘기

1. 다들 jwt는 어디에 두고 있는지 궁금함, 난 지금 로컬스토리지에 있는데 다 보이는 형태라서 괜찮나 싶음
   1. 우리팀에선 그걸로 뭘할 수 있는데 이런 반응이라서…
2. jotai로 마이그레이션할 예정임

### 상태란

- 앱의 시나리오에 따라서 지속적으로 변경될 수 있는 값을 의미한다.

### 상태로 분류될 수 있는 것

UI, URL, 폼, 서버에서 가져온 값

### 커스텀훅의 단점

```jsx
const useCounter = () => {
  const [counter, setCounter] = useState(0);

  const inc = () => {
    setCounter((cur) => cur + 1);
  };
  return { counter, inc };
};

const App = () => {
  const { counter, inc } = useCounter();
};
```

`useCounter`를 사용할 때마다 컴포넌트 별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수밖에 없다. 결론적으로 컴포넌트별로 상태의 파편화를 만든다.

- 이렇게 useState를 기반으로 한 상태를 지역상태라고 하며 해당 컴포넌트에서만 유효한 단점이 있다.
- 똑같이 사용하려면 부모컴포넌트를 만들어서 거기서 선언하고 밑에 내려주는 방식밖에 없다.
- 클로저 내부에서 관리되어 지역 상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있다는 단점이 있다.

### 다양한 상태관리 라이브러리들의 공통점

1. useState, useReducer의 한계(컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점)을 극복하기 위해 외부 어딘가에 상태를 둔다. 이는 컴포넌트의 최상단, 내지는 상태가 필요한 부모가 될수도 있고 혹은 격리된 js 스코프일 수도 있다.
2. 이 외부 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

---

### jotai

- 컴포넌트 외부에서도 사용할 수 있다는 장점.
- 키관리도 안해도 댐

# 7장

### 7.5 : 메모리 탭

<aside>
💡 앱에서 발생하는 메모리 누수, 속도 저하, 웹 프리징 현상을 확인할 수 있는 유용한 도구

</aside>

## 프로파일링 유형 3가지

1. 힙 스냅샷
   - **현재 메모리 상황**을 사진 찍듯이 알 수 있다.
2. 타임라인의 할당 계측
   - 현재 메모리 시점이 아닌 **시간의 흐름에 따른 메모리 변화**를 알고싶을 때 사용한다.
   - 주로 로딩되는 과정의 메모리 변화, 페이지에서 어떠한 상호작용을 했을 때 사용한다.
3. 할당 샘플링
   - 메모리 공간을 차지하고 있는 JS 함수를 볼 수 있다.

---

### 자바스크립트 VM 인스턴스 선택

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ef19e2b8-cc83-48d8-988a-d8a37ad19fb7/57b40db6-ed84-4709-b2d6-a38d71d88d29/Untitled.png)

- 실제 해당 페이지가 JS 힙을 얼마나 점유하고 있는지 나타낸다.
- 이 크기는 js 실행에 따라 실시간으로 바뀐다.

### 힙 스냅샷

- 제대로 활용하려면 스냅샷 2개 이상을 촬영한 다음, 그 차이만 비교하는 것이 훨씬 수월하다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ef19e2b8-cc83-48d8-988a-d8a37ad19fb7/6e43aba1-9321-4d87-8690-e0b864b8edb2/Untitled.png)

- 하기 전 상태와 하고난 후 상태를 비교하여서 어떠한 변수가 메모리를 크게 잡아먹고 있는지 확인할 수 있다.
- 우클릭한 객체를 대상으로 **전역변수로 저장**을 누르면 해당 변수의 값이 전역변수에 저장되어 console에 나온다
- 얕은 크기와 유지된 크기의 차이점
  - 얕은 크기는 객체 자체가 보유하고 있는 메모리 크기를 나타낸다.
  - 유지된 크기는 객체 자체 뿐만 아니라 다른 부모가 존재하지 않는 모든 자식 객체들의 크기까지 더한 값이다.
  - 만약 Y라는 객체가 `X(크기 52)`라는 변수를 내부에 갖고 있다면 Y라는 객체의 얕은 크기는 48이지만 유지된 크기는 100일 것이다
- 메모리 누수를 찾는 방법
  - 유지된 크기가 더 크다면 해당 객체는 복잡한 참조 관계를 가지고 있으면서 이런 객체가 오랜시간 동안 메모리에 유지된다면 그로 인해 많은 메모리를 점유할 수 있어서 메모리 누수가 의심스럽다면 이러한 두 크기의 차이가 큰 객체를 최우선으로 찾아야한다.
- useCallback과 useMemo가 잘 동작되는지 확인하는 방법
  - closure에서 확인 가능
  - 재생성되지 않았다면 다음에 찍은 스냅샷에는 생성되지 않는다.

### 7.6 : Next.js 환경 디버깅하기

```jsx
$ npm i -d cross-env
```

```jsx
"dev": "cross-env NODE_OPTIONS='--inspect' next dev"
```

1. chrome://inspect/#device로 이동
2. 클릭

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ef19e2b8-cc83-48d8-988a-d8a37ad19fb7/9e0524b5-6853-423d-8999-5575b05eb5ff/Untitled.png)

# 8장

- 그냥 알던 내용들인데 현업에 도입하게된다면 기한 맞추느라 바빠서 배보다 배꼽이 더 커지는 상황이 되어버려서 도입하지는 않을 예정.
