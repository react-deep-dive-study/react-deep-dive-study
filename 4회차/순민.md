# 리액트와 상태관리 라이브러리

## Flux 패턴의 등장

웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 액션이 발생해서 이 상태가 변했는지 등을 추적하하고 이해하기가 매우 어려운 상황이었다.
이러한 문제의 원인을 양방향 데이터 바인딩으로 봤다.(뷰(HTML)가 모델(Javascript)을, 모델이 뷰를 변경 가능)
그래서 Flux패턴이 나왔고 리액트 16.8이후에는 다양한 훅 API가 나옴에 따라 이전에는 볼 수 없던 방식의 상태 관리가 등장을 했다.(React Query,SWR,Recoil,Zustand 등..)

## 리액트 훅으로 시작하는 상태 관리

- 가장 기본적인 방법으로 커스텀 훅을 이용하여 useState와 useReducer로 동일한 인터페이스의 상태를 생성하고 관리하는 것이다.
- get,set,subscribe를 이용해서 store를 직접 구현하는게 흥미로웠다. (나중에 따로 정리하면 좋을거 같다.)

# 개발자 도구 활용 (메모리 탭)

- 애플리케이션에서 발생하는 메모리 누수, 속도 저하, 웹페이지 프리징 현상을 확인할 수 있다.
- 프로파일 유형이 세 가지가 있다.
  - 힙 스냅샷 : 현재 메모리 상황을 사진 찍듯이 촬영을 한다.
  - 타임라인의 할당 계측 : 시간의 흐름에 따라 메모리의 변화를 살펴본다.(주로 로딩이 되는 과정의 메모리 변화 또는 페이지에서의 어떤 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용한다.)
  - 할당 샘플링 : 메모리 공간을 차지하고 있는 자바스크립트 함수를 볼 수 있다.

## 힙 스냅샷

- 메모리 누수를 찾을 때 얕은 크기(객체 자체의 크기)는 작으나 유지된 크기(객체가 참조하고 있는 모든 객체들의 크기)가 큰 객체를 찾아야 한다.
- 두 크기의 차이가 큰 객체는 다수의 다른 객체를 참조하고 있다는 뜻이다.

## 타임라인 할당 계측

- 시간의 흐름에 따른 메모리의 변화를 비롯해 메모리 변화를 일으킨 변수가 무엇인지, 어느정도의 크기를 차지하고 있는지 확인을 할 수 있다.

## 할당 샘플링

- 문제가 되는 함수와 해당 함수가 어느 파일에서 어떻게 정의됐는지도 확인할 수 있다.
- 타임라인 할당 계측과 유사하지만, 프로파일링할 때 브라우저에 주는 부담을 최소화할 수 있다.

# Next.js 환경 디버깅하기

- Next.js 프로젝트를 디버그 모드로 실행을 하면 된다.

```
"dev": NODE_OPTIONS='--inspect' next dev
```

- 위 명령어를 실행후 웹소켓 주소가 나타나면 디버거에 연결된 준비가 된 것이다
- chrome://inspect 로 이동후에 `Open dedicated DevTools for Node`를 클릭하고 개발자도구를 확인하자

## Next.js서버에 트래픽 유입시키기

- 디버거 모드로 Next.js를 실행을 했다면, 트래픽이 서버로 몰리는 상황을 시뮬레이션을 해보면 된다.
- 오픈소스 도구인 `ab`를 사용해서 HTTP서버의 성능을 벤치마킹을 해준다.

```
 ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
```

`http://127.0.0.1:3000`을 향해 한 번에 50개의 요청을 총 10,000회 시도한다는 뜻이다.
요청으로부터 응답받는 데 걸린 시간과 바이트 크기 등 다양한 정보를 확인할 수 있다.

# 리액트 팀이 권장하는 리액트 테스트 라이브러리

- DOM Testing Library기반의 React Testing Library를 많이 사용한다.
- DOM Testing Library는 jsdom기반이고 jsdom은 node.js환경에서 마치 HTML이 있는것 처럼 DOM을 조작할 수 있다.
- userEvent는 fireEvent와 차이가 있다.
- useEvent.click을 수행한다면 내부적으로 다음과 같은 fireEvent가 실행이 된다.
  - fireEvent.mouseOver
  - fireEvent.mouseMove
  - fireEvent.mouseDown
  - fireEvent.mouseUp
  - fireEvent.click
- userEvent는 사용자의 작동을 fireEvent를 통해 좀 더 자세하게 흉내 내는 모듈이라고 생각하면 된다.
