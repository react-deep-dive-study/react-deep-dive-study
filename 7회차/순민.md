# 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 웹사이트와 성능

**웹 사이트에서 사용자가 기대하는 사항**

- 웹사이트를 방문한 목적을 손쉽게 달성
- 첫 번째 목적을 달성하는 데 걸리는 시간이 짧아야 한다.
- 보안이 철저해야 한다.

## 핵심 웹 지표란?

**구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.**

- 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)
- 최초 입력 지연(FID: First Input Delay)
- 누적 레이아웃 이동(CLS: Cumulative Layout Shift)

특정 문제를 진단하는 데 사용되는 지표

- 최초 바이트까지의 시간(TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

위 세가지만 지켜진다면 내부적으로 어떤 코드로 어떻게 이뤄져 있는지는 고객들에게 전혀 중요하지가 않다.
모든 서비스는 사용자가 느끼는 성능이 제일 중요하다.

## 최대 콘텐츠풀 페인트(LCP)

- 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간이다.
  - 뷰포트 : 사용자에게 현재 노출되는 화면 (뷰포트의 크기는 기기마다 다르다.)

가장 큰 요소로 고려되는 것은 5가지가 있다.

- `<img>`
- `<svg>` 내부의 `<image>`
- poster 속성을 사용하는 `<video>`
- `url()`을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
  - `<p>`,`<div>`등이 포함된다.

> DOMContentLoaded와 LCP는 관련이 없다. DOMContentLoaded이벤트는 스타일시트,이미지,하위 프레임의 로딩은 기다리지 않는다.

LCP 판단 기준

- LCP는 되도록 2.5초 이내로 응답이 오도록 만들자. 4초 이상 걸리게 된다면 나쁨으로 판단된다.

## LCP 점수 높이는 방법

### 최대한 텍스트 이용하기

- 좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대 영역, 즉 LCP 예상 영역에 이미지가 아닌 문자열을 넣는 것이다.
- 이미지를 아무리 최적화해도 텍스트 노출보다 느리기 때문이다.

### 이미지를 어떻게 불러올 것인가?

- img태그 : 브라우저의 프리로드 스캐너에 의해 먼저 발견되어 빠르게 요청이 일어난다.
  - 프리로드 스캐너는 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다.
- svg내부의 img태그 : 모든 리소스를 불러오고 img를 부른다. 프리로드 스캐너가 동작하지 않아서 병렬적으로 다운로드가 일어나지 않는다.
- video의 poster : 프리로드 스캐너에 의해 조기에 발견되어 `<img>`와 같은 성능을 나타낸다.
- `background-image: url()`: background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다. 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다.

### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축: 가능한 이미지를 최소한의 용량으로 서비스를 하자
- lazy옵션 주의: `loading=lazy`는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략이다.
  - 최대 콘텐츠 풀(LCP)리소스에는 lazy옵션을 사용하지 않는 것이 좋다.
- fadein과 같은 각종 애니메이션: fadeIn ease 10s와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어진다.
- 클라이언트에서 빌드하지 말 것: 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져가는 것이 제일 좋다. "만약, useEffect에서 최대 콘텐츠풀 페인트 영역을 노출해주는 코드가 있다면 최대 콘텐츠풀 페인트는 HTML을 다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽은 후 영역을 노출해주기 전까지 늦어지게 된다."
- 최대 콘텐츠풀 리소스는 직접 호스팅: 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다.
  - Cloudinary 같은 이미지 최적화 서비스를 사용해서 이미지 크기도 줄이고, 포맷도 변환하고, 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한 이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다.
  - 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다.

## 최초 입력 지연(FID)

- 자바스크립트는 '싱글 스레드'이기 때문에 콜스택에 많은 작업들이 실행중일 경우 이벤트 리스너와 같은 다른 작업을 실행할 수 없어서 지연이 발생한다. 즉, 이벤트가 발생하는 시점에 최대한 메인스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야한다.

### 개선 방법

크롬에서 개발자 도구 > 커버리지를 클릭하면 사용하지 않는 코드가 얼마나 있는지 확인할 수 있다.

자바스크립트 코드 최소화를 하면 된다.

- 최초 로딩에 필요하지 않는 내용을 나중에 불러오면 된다.(팝업이나 레이어) 리액트의 Suspense와 lazy혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다.
- 폴리필이 꼭 필요한지 확인하자

- 타사 자바스크립트(GA나 Firebase같은 타사 스크립트를 넣는 경우) 코드 실행의 지연
  - `<script>`의 async와 defer를 이용해서 지연 불러오기를 하면 된다.
  - defer: 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다. 그리고 스크립트가 다운로드가 완료됐다 하더라도 페이지가 완전히 로딩된 이후에 맨 마지막에 실행된다.
  - async: defer처럼 다른 리소스와 함께 병렬로 다운로드된다. 하지만, async리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드가 완료되는 것을 기다리지 않고 바로 실행한다.
  - 둘 다 없는 경우: script를 만나는 순간 다운로드가 우선된다. 다운로드가 완료되면 코드 실행이 우선된다. 다운로드와 실행이 끝날 때까지 다른 작업이 미뤄진다.

## 누적 레이아웃 이동(CLS)

미리 노출이 예상되는 부분을 HTML로 자리 잡아 두는 것이 누적 레이아웃 지표에 큰 도움이 된다.

### 개선 방법

**추가 공간 확보**

- 리액트에선 useEffect의 사용이 불가피하다면 useLayoutEffect 훅을 사용해 보는 것 또한 검토해 볼 만 하다.
  - 그러나 useLayoutEffect는 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 때문에 사용자에게 로딩이 오래 걸리는 것과 같이 보일 수 있다. 신중하게 사용하자!
- 스켈레톤 UI처럼 미리 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다.
- 가장 좋은 방법은 서버 사이드 렌더링이다.

**폰트 로딩 최적화**

- link의 preload를 이용해서 폰트를 로딩시킨다. 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리스소로 간주되므로 브라우저는 리소스를 더 빠르게 사용할 수 있도록 준비해 준다.
- font-family: 폰트를 불러올 수 있는 방법은 크게 다섯 가지로 나뉜다.
  - auto(기본값): 브라우저가 폰트를 불러오는 방법을 결정한다.
  - block: 폰트가 로딩되기 전까지 렌더링을 중단한다.
  - swap: FOUT 방식이다. 우선 폴백 폰트로 글자를 렌더링한 다음, 웹 폰트의 로딩이 완료되면 웹 폰트를 적용한다.
  - fallback: 100ms간 텍스트가 보이지 않고, 그 이후에 폴백 폰트로 렌더링한다. (3초 안으로 폰트가 로딩된다면 해당 웹 폰트로 전환, 그렇지 않다면 폴백 폰트를 사용한다.)
  - optional: fallback과 유사하다. 하지만, 브라우저가 네트워크 상태를 파악해 일정기간 폰트를 다운하지 못하면 연결을 취소한다.

**적절한 이미지 크기 설정**

```css
img {
  width: 100%;
  height: auto;
}
```

width:100%와 height:auto는 누적 레이아웃 이동이 커지는 결과를 낳는다.
이미지가 완전히 로딩 완료된 이후에 기기 너비만큼 높이를 계산해서 이미지 크기만큼 자리 잡을 수 있게 된다.
(반응형 웹사이트에 최적화할 수 있는 기법으로, 기기의 너비가 어떻게 되든 원본 이미지의 가로세로 비율이 일정해 사용자에게 최적의 이미지를 보여줄 수 있다는 장점이 있다.)

위 문제를 해결하려면 aspect-ratio 속성을 통해 width,height를 원하는 비율로 미리 설정을 해둔다. 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다.

만약 반응형 이미지를 사용하고 싶다면 srcset속성을 사용하는 것이 좋다. 가로세로 비율이 똑같으나 크기가 다른 여러개의 이미지를 준비해서 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비한다.

```html
<img
  width="1000"
  height="1000"
  src="image-1000.jpg"
  srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
  alt="이미지"
/>
```

## 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표

**최초 바이트까지의 시간(TTFB)**

- 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정한다.
- SSR에서 주의 깊게 봐야한다. 서버에서 첫 번째 HTML을 만들기 위한 작업이 많거나 느릴수록 최초 바이트까지의 시간이 오래걸린다.
- 리액트 서버사이드 렌더링이라면 `renderToNodeStream`,`renderToStaticNodeStream`과 같은 스트리밍 API를 사용하는것이 좋다.
  - `renderToString`은 완전히 HTML을 그리고 나서야 다운로드가 되지만, 스트리밍은 완성된 영역부터 조각조각 받을수 있기 때문
- 웹페이지의 주된 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋다. (응답해야 할 서버가 사용자와 가까울수록 응답 속도가 빨라지기 때문)

**최초 콘텐츠풀 페인트(FCP)**

페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다.

최초 콘텐츠풀 페인트를 개선하는 방법

- 최초 바이트까지의 시간(TTFB)을 개선: 일단 뭐라도 다운로드가 시작돼야 렌더링을 할 수 있기 때문
- 렌더링을 가로막는 리소스 최소화: 자바스크립트나 CSS같은 렌더링을 가로막는 리소스를 최소화 한다. 렌더링을 방해하는 리소스를 비동기적으로 로드하도록 한다.
- Above the Fold에 대한 최적화: 신문에서 비롯된 용어인데, 웹에서는 최초에 스크롤을 굳이 하지 않아도 보이는 영역을 일컫는 말이다.
- DOM 크기 최소화: HTML의 크기가 크다면, 즉 DOM이 복잡하고 크다면 그만큼 렌더링되는 데 시간이 오래 걸린다. 구글의 기준에 따르면 전체 DOM 노든느 1500개 미만으로, 깊이는 32단계 정도, 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 한다.

## 중요한 점

- LCP 최적화 방법 및 주의사항
- FID 디버깅 하는 법 (사용하지 않는 자바스크립트 코드 확인)
- 적절한 이미지 크기 설정하기

## 이야깃거리

- 다른 출처에서 이미지를 가져오는것이 네트워크 커넥션부터 다시 수행해서 최적화에 별로 좋은 영향을 미치지 않는다는데 정말 그럴까?
  - cdn서비스에서 서빙하는 최적화된 이미지를 가져오는게 동일 출처의 이미지를 로드 하는것 보다 네트워크 커넥션 때문에 비용이 더 큰가?
