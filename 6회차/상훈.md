### 리액트 서버 컴포넌트

- 서버 사이드 렌더링과 완전히 다른 개념이다.
- 하나의 언어, 프레임워크, api와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
- 일부는 클라이언트 컴포넌트, 일부는 서버에서 렌더링되는 것이다.
- 명심할 점 : **클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다는 것**
  - 만약 클라이언트 컴포넌트가 서버 컴포넌트를 불러오게 된다면 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에(서버 환경이 브라우저에는 존재하지 않으므로) 컴포넌트를 호출할 수 없다.

### 서버 컴포넌트

1. 요청이 오면 그 순간 딱 한번만 실행될 뿐이므로 상태를 가질 수 없다.

- 렌더링 생명주기도 사용할 수 없다.

2. 브라우저에서 싱행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 window, document 등에 접근할 수 없다.
3. DB, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있따.
4. 컴포넌트 자체가 async한 것이 가능하다.
5. 다른 서버 컴포넌트를 렌더링하거나 div,span,p같은 요소를 렌더링하거나 혹은 클라이언트 컴포넌트를 렌더링할 수 있다.

### 클라이언트 컴포넌트

1. 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나 서버 전용 훅이나 유틸리티를 불러 올수 없다.
2. 서버 컴포넌트를 자식으로 갖는 구조는 가능하다.

- 클라이언트 입장에서 봤을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입해서 보여주기만 하기 때문이다.

### 공용 컴포넌트

- 서버와 클라이언트 모두에서 사용할 수 있다.
- 공통으로 사용할 수 있는 만큼 당연히 서버컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

### 리액트는 어떻게 판단할까?

- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다
  - 즉, 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류한다.
  - 대신, 클라이언트 컴포넌트 라는 것을 명시적으로 선언하려면 use client를 작성해두면된다.

### Next.js에서의 리액트 서버 컴포넌트

- 13버전에 들어가면서 /app 디렉터리에 구현되어 있다.

스트리밍을 활용한 점진적인 페이지 불러오기

- 스트리밍 : 하나의 페이지가 완료될 때까지 기다리는 게 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 것
- 사용자가 일부라도 페이지와 인터렉션을 할 수 있다.
- 핵심 웹 지표인 최초 바이트까지의 시간과 최초 컨텐츠풀 페인팅을 개선하는 데 도움을 준다.

장점 : 페이지가 로딩중이라는 인식과 지루함을 덜어줄 수 있다.

- Loading은 `Suspense`를 기반으로 만들어진 Next.js의 규칙이기 때문에 직접 Suspense를 사용하는 것도 동일한 혜택을 누릴 수 있다.
- 서버 액션
- API를 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능
- 서버 컴포넌트와 다르게 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.

### ??

- [ ] page.js와 layout.js 는 반드시 서버 컴포넌트여야 한다
  - 루트에 있는것만 그렇고 다른 것들은 상관 없는 듯 - 741.page
- [ ] 전역 상태로 표현해야 하는 값들에 대해서
  - 페이지 전환시 넘겨야하는 상태를 url에 표기하고 싶지 않을 때
  - ex) 블로그 글에 글 추가하기 기능이 있다면, previous_id를 url에서 사용자가 조작하거나 할 수 있는 경우를 방지하기 위함.
    - 클라이언트에서 previous_id의 유효성 검사를 체크해줄 수 있기도 하지만,,, 흠흠,,, 구현 방법중 하나인거 같긴함..
