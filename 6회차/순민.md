# Next.js 13과 리액트 18

## 13버전 이전의 Next.js와 변경된 점

- 13버전 이전까지 모든 페이지는 각각의 물리적으로 구별된 파일로 독립돼 있었다. 공통 레이아웃을 유지하는 방법은 \_app 파일에서의 정의밖에 방법이 없었다.
- 13버전 이후 중첩 layout구성이 가능해졌다.
- 13버전의 page에서는 params와 searchParams를 props로 받을 수 있다.

## 리액트 서버 컴포넌트

- 리액트 18에서 새로벡 도입된 개념이다. (서버 사이드 렌더링과 완전히 다른 개념이다.)

### 기존 리액트 코드의 CSR과 SSR에서의 동작 과정

- 리액트의 모든 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드 처리가 이뤄진다.(리액트 로직에 대한 처리 때문)
- 리액트로 만들어진 페이지를 방문하면 리액트 실행에 필요한 코드를 다운로드하고 리액트 컴포넌트 트리를 만든 다음 DOM에 렌더링하는 과정을 거쳐야한다.
- SSR의 경우는 미리 서버에서 DOM을 만들고 클라이언트에선 서버에서 만들어진 DOM을 기준으로 하이드레이션을 진행한다.
- SSR방식은 좋아보이지만 명백한 한계점이 존재했다.

### 서버 사이드 렌더링의 한계

#### 1.자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다

```jsx
import sanitizeHtml from "sanitize-html";

function Board({ text }: { text: string }) {
  const html = useMemo(() => sanitizeHtml(text), [text]);
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}
```

- 위 컴포넌트는 63.3kB에 달하는 라이브러리를 필요로 하며, 이는 클라이언트인 브라우저에서 해당 라이브러리를 다운로드해야할 뿐만 아니라 실행까지 거쳐야 한다.
- 만약, 이 컴포넌트를 서버에서만 렌더링하고 클라이언트는 결과만 받는다면 어떨까?
  - sanitize-html은 서버만 가지고 있고, 서버에서는 해당 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물만 클라이언트에 제공 (브라우저에서 라이브러리를 다운로드후 실행하지 않아도 된다.)

#### 2.백엔드 리소스에 대한 직접적인 접근이 불가능하다

- REST API를 이용해야 한다.

#### 3.자동 코드 분할이 불가능하다

- 코드 분할 : 하나의 거대한 코드 번들 대신, 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩을함으로서 앱을 초기화하는 속도를 높여주는 기법이다.

```jsx
import React from "react";

const CompoA = lazy(() => import("./CompoA.js"));
const CompoB = lazy(() => import("./CompoB.js"));

function ParentCompo(){
    if(..){
      return <CompoA/>
    }else{
      return <CompoB>
    }
}
```

- 일반적으로 리액트에서는 lazy를 사용해서 이를 구현했다.
- 이 기법의 단점으로는 if문을 판단하기 전까지 어떤 지연 로딩한 컴포넌트를 불러올지 결정할 수 없다.
- 만약 이 코드 분할을 서버에서 자동으로 수행해 준다면? 자동 코드 분할이 가능해진다.
- 어떤 컴포넌트를 미리 불러와서 클라이언트에 내려줄지 서버에서 결정할 수 있다면 코드 분할의 이점을 100% 활용할 수 있게 된다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
  - 하나의 요청으로 A컴포넌트가 렌더링되고, A컴포넌트의 렌더링 결과로 B컴포넌트 그리고 그 아래의 컴포넌트들을 렌더링할 때 A컴포넌트의 렌더링이 끝나기 전까지는 하위 컴포넌트의 요청과 렌더링이 끝나지 않는다.

## 서버 컴포넌트란?

- 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법이다.
- 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다.(서버 환경이 브라우저에 존재하지 않으므로)
- 리액트 컴포넌트 트리엔 서버 컴포넌트와 클라이언트 컴포넌트가 혼재되어 있다.
- 모든 컴포넌트는 서버 컴포넌트가 될 수도 있고 클라이언트 컴포넌트가 될 수도 있다.
- 이런 구조가 가능한 이유는 children으로 자주 사용되는 ReactNode 덕분이다.

```jsx
import ClientComponent from "./ClientComponent";
import ServerComponent from "./ServerComponent";
export default function ParentServerComponent() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

- 이 코드는 서버 컴포넌트와 클라이언트 컴포넌트가 있으며, 동시에 서버,클라이언트에서 모두 사용할 수 있는 공용 컴포넌트(ParentServerComponent)가 있다는 것이다.

### 서버,클라이언트,공용 컴포넌트의 차이와 제약사항에 대하여

- 서버 컴포넌트

  - 요청이 오면 그 순간 서버에서 딱 한 번 실행되므로 상태를 가질 수 없다.(useState,useReducer)
  - 렌더링 생명주기도 사용할 수 없다. 한번 렌더링되면 그걸로 끝이기 때문 (useEffect,useLayoutEffect)
  - 당연히 DOM API사용을 하지 못한다.
  - 서버에만 있는 데이터(db,file system...)에 접근이 가능하다. (컴포넌트 자체가 async한 것이 가능하다.)
  - 다른 서버 컴포넌트를 렌더링하거나, 클라이언트 컴포넌트를 렌더링할 수 있다.

- 클라이언트 컴포넌트

  - 서버 컴포넌트를 불러오거나 서버 전용 훅이나 유틸리티를 불러올 수 없다.
  - 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링할 때, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.
    - 이유 : 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고, 클라이언트 컴포넌트는 이미 서버에서 만들어진 트리를 삽입해서 보여주기만 하면 되기 때문
  - 상태를 가질 수 있다.

- 공용 컴포넌트
  - 이 컴포넌트는 서버와 클라이언트 모두에서 사용할 수 있다. (서버,클라이언트 컴포넌트의 모든 제약을 받는다.)

### 리액트의 서버,클라이언트,공용 컴포넌트의 판단 기준

- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다.
- 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 파일의 맨 첫 줄에 'use client'를 작성하면 된다.

## 서버 사이드 렌더링과 서버 컴포넌트의 차이

- SSR의 경우엔 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다. 그리고 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행한다. (초기에 인터랙션은 불가능하지만, 정적인 HTML을 빠르게 내려주는게 포인트이다.)
- 따라서 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 js를 다운로드하고, 파싱하고, 실행을 해야한다.
- 서버 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML로 빠르게 전달받을 수 있다. 이 두 가지 방법을 모두 결합하면 클라이언트 및 서버 컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받아야 하는 자바스크립트의 양도 줄어들어 브라우저의 부담을 덜 수 있다.

## 서버 컴포넌트는 어떻게 작동하는가?

- 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다.
- 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다.
  브라우저는 이후에 이 결과물을 받아서 역직렬화한 다음 렌더링을 수행한다.
- 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버에서 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다.

### 서버 컴포넌트 작동 방식의 특별한 점

- 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있다.
- 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않다. 컴포넌트별로 번들링이 별개로 돼 있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능하다.
- SSR과는 다르게 결과물이 HTML이 아닌 JSON형태로 보내진다. 클라이언트의 최종 목표는 리액트 컴포넌트 트리를 서버 컴포넌트와 클라이언트 컴포넌트의 두 가지로 조화롭게 구성하는 것이다.

## 스트리밍을 활용한 점진적인 페이지 불러오기

- 서버 사이드 렌더링은 요청받은 페이지를 모두 렌더링해서 내려줄 때까지는 사용자에게 아무것도 보여줄 수 없었다. 그리고 페이지를 다 받았다 하더라도 하이드레이션 과정을 거쳐야만 비로소 사용자가 사용할 수 있는 페이지가 된다.
- 이를 해결하기 위해 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍이 도입됐다.
- TTFB와 FCP를 개선하는 데 큰 도움을 준다.

### 스트리밍 활용법

- 경로에 loading.tsx 배치 : loading은 next의 예약어로 존재하는 컴포넌트이다. 렌더링이 완료되기 전에 보여줄 수 있는 컴포넌트를 배치할 수 있는 파일이다.
- Suspense 배치: 좀 더 세분화된 제어를 하고 싶다면 직접 리액트의 Suspense를 배치하는 것도 가능하다.

## getServerSideProps와

- getServerSideProps를 사용하는 애플리케이션에서는 `<script id="__NEXT_DATA__" type="application/json">`라고 하는 특별한 태그가 추가돼 있었다.(서버에서 미리 만들어진 정보를 바탕으로 클라이언트에서 하이드레이션 진행)
- 리액트 18에서는 서버 컴포넌트에서 렌더링한 결과를 직렬화 가능한 데이터로 클라이언트에 제공하고, 클라이언트는 이를 바탕으로 하이드레이션을 진행하게 된다. 각 스크립트는 하나의 서버 컴포넌트 단위이다.

## 중요한 점

- 서버 컴포넌트
- 코드분할
- 스트리밍

## 이야깃거리

- error.js와 loading.js의 활용도에 대해
  - Errorbounday와 Suspense에 대한 컴포넌트를 따로 만들어서 관리해주는게 더 편하지 않을까?
  - error.js와 loading.js를 이용하여 error와 suspense에 대한 처리를 할 경우 중복해서 코드를 계속 작성해야하는 불편함이 있을거 같다.
- Next13 app router에서는 ssr이 사라진걸까?(응답값이 html로 떨어지는 형태의 ssr)
