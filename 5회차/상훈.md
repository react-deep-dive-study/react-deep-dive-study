# 10장 : 리액트 17과 18의 변경사항 살펴보기

리액트는 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀더 효율적으로 관리한다. : 이벤트 위임을 적극 활용한다, = ex) li에 연결하지 않고 ul에 이벤트를 연결하는 방식

17버전 부터는 document가 아닌 root요소에 달린다.

그 이유는, 점진적 업그레이드 지원, 바닐라js코드, jquery등이 혼재돼 있는 경우 혼란을 방지하기 위함이다.

## React 18버전

### useId

<aside>
💡 컴포넌트 별로 유니크한 값을 생성하는 훅

</aside>

- 클라이언트와 서버에서 일치하면서 고유한 값을 생성할 수 있다.

### useTransition

<aside>
💡 UI 변경을 막지 않고 상태를 업데이트할 수 있다.

</aside>

- 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 미룰 수 있으며, 더 좋은 UX를 제공할 수 있다.
- 상태 변경으로 인해 무거운 작업이 발생하고 이로 인해 렌더링이 가로막힐 여지가 있는 경우에 사용할 수 있다.
- `startTransition` 안에는 상태 업데이트하는 함수만 넘길 수 있다.

```jsx
let [isPending, startTransition] = useTransition();
```

1만개의 컴포넌트를 바꾸는 state

성능저하를 일으키는 변경함수를 startTransition로 콜백함수 형태로 감싸줘라

### 동작원리

- startTransition 안의 코드를 늦게 처리해준다.
  - 코드 시작을 뒤로 보낸다.
  - 우선순위를 뒤로 보냄
  - 즉, 늦게 시작하게 함

### isPending

- startTransition가 처리 중일 때 `true` 인 변수이다.

### useDeferredValue

- 해당 hook에 넣은 state를 늦게 처리해준다
- 해당 state의 변동사항이 생기면 늦게 처리해준다.
- 특정 시간동안 발생하는 이벤트를 하나로 인색해 한번만 실행하게 해주는 디바운스와 비슷하지만 디바운스 대비 장점이 몇가지 있다.

1. 디바운스는 고정된 지연시간이 필요하지만 useDeferredValue는 고정된 지연시간 없이 첫번째 렌더링이 완료된 이후에 useDeferredValue로 지연된 렌더링을 수행한다.
   1. 중단도 되며 사용자의 인터렉션을 차단하지도 않는다.

- 오로지 값만 받아야하는 상황에 사용하며 좋다.

### useSyncExternalStore

- 상태 관리라이브러리를 위한 훅
- 외부에서 상태의 동시성을 지키기 위함.
- 라이브러리를 만드는 것이 아니라면 참고만 하고 사용하지 않는 것이 좋다.

### useInsertionEffect

- CSS in JS를 위한 훅
- 레이아웃을 계산하기 전에 실행된다.
- 브라우저가 다시금 스타일을 입혀서 DOM을 재계산하지 않아도 된다는 점.
- 라이브러리를 만드는 것이 아니라면 참고만 하고 사용하지 않는 것이 좋다.

## 궁금한 것 : 이벤트 위임 관련

동일한 이벤트 함수를 가진 컴포넌트를 map으로 돌린다면 이것도 최상단에서 하나의 함수로 이벤트 위임으로 할수 있지 않을까?

리액트 자체적으로 뭘 했으려나?

```jsx
부모 컴포넌트

자식 컴포넌트
  - 함수
```

```jsx
부모 컴포넌트
  - 함수

자식 컴포넌트
```
