# 리액트 16과 17버전 차이

## 이벤트 위임 방식의 변경

- 리액트에서 버튼에 onclick 이벤트를 추가하면 해당 DOM요소에 이벤트 핸들러를 부착하는것이 아니다.
- 이벤트 타입당 하나의 핸들러를 루트에 부착을 한다. 이러한 방식을 이벤트 위임이라고 한다.
- 리액트는 이밴트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리한다.

- 16버전에서는 document에 이벤트가 부착이 되었었는데, 17버전은 document가 아닌 리액트 컴포넌트 최상단 트리인 `div#root` 에 부착이 된다.
- 최상단 트리에 핸들러를 부착하게 되면 리액트 컴포넌트 트리 수준으로 격리가 된다. 이벤트 버블링으로 인한 혼선을 방지할 수 있다.

이 상황에서 React168컴포넌트가 이벤트 전파를 막는 e.stopPropagation을 실행하면 어떻게 될까?
이미 모든 이벤트가 document에 있으므로 document의 이벤트 전파는 막을 수 없다. 따라서 e.stopPropagation의 실행이 무색하게 바깥에 있는 React1614에도 이 이벤트를 전달받게 될 것이다.
하지만, react 17버전은 리액트 컴포넌트 트리 수준으로 각 이벤트를 격리시키므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다.

```tsx
// react 16.14
function React1614() {
  function App() {
    function 안녕하세요() {
      alert("안녕하세요! 16.14");
    }
    return <button onClick={안녕하세요}>리액트 버튼</button>;
  }
  return ReactDOM.render(<App />, document.getElementById("React-16-14"));
}

// react 16.8
function React168() {
  function App() {
    function 안녕하세요() {
      alert("안녕하세요! 16.8");
    }
    return <button onClick={안녕하세요}>리액트 버튼</button>;
  }
  return ReactDOM.render(<App />, document.getElementById("React-16-8"));
}

// 렌더링 후
<html>
  <body>
    <div id="React-16-14">
      <div id="React-16-8"></div>
    </div>
  </body>
</html>;
```

## 이벤트 풀링 제거

- 리액트 16에서는 브라우저의 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용했다.
- 이벤트 풀링 시스템을 이용(따로 정리해봐도 좋을 거 같다)
- 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안되므로 풀링 개념을 삭제했다.

## useEffect 클린업 함수의 비동기 실행

- 16버전에서는 동기적으로 처리가 됐다. 동기적으로 실행이 되기 때문에 클린업 함수가 완료되기 전 까지 다른 작업을 하지 못했다.
- 17버전부터는 비동기적으로 실행이 된다. 커밋 단계가 완료될 때까지 지연이 된다.(화면이 업데이트가 완전히 끝난 이후에 실행)

# 리액트 18버전 살펴보기

## useId

- 컴포넌트별로 유니크한 값을 생성해주는 훅이다.
- 리액트 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 곂치지 않는다.
- 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때 서버와 클라이언트에서 동일한 값을 가진다.
- 만약 ssr환경에서 `Math.random()`으로 처리하면 서버에서 렌더링했을 때의 `Math.random()`값과 클라이언트에서 하이드레이션 했을 때의 `Math.random()`의 값이 다르다.

## useTransition

- UI변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅이다.
- 긴급하지 않은 상태 업데이트를 할 때 유용하다.
- 리액트 18의 변경 사항의 핵심 중 하나인 '동시성'을 다룰 수 있는 새로운 훅이다.
- 과거의 모든 리액트는 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만, useTransition과 같은 동시성 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 지금 진행중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업이 가능하다.
- startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
- startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. setTimeout과 같은 비동기 함수를 넣으면 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나게 된다.

## useDeferredValue

- 렌더링이 급하지 않은 부분을 지연할 수 있게 도와준다.
- debounce와 비슷하다고 생각할 수 있다.
- 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 useDeferredValue로 지연된 렌더링을 수행한다.

## useTransition과 useDeferredValue

- useTransition은 state값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state값 자체만을 감싸서 사용한다.
- 지연된 렌더링을 한다는 점에서는 둘다 동일한 역할이다.
- 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 useTransition
- 컴포넌트의 props와 같이상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 useDeferredValue를 사용하는 것이 좋다.

## useSyncExternalStore

- 테어링(tearing) 현상을 해결하기위해 나온 훅이다.
- 리액트 18에서는 useTransition과 useDeferredValue의 훅 처럼 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있기 때문에 리액트 17에서의 useSubscription이 useSyncExternalStore로 대체됐다.
- 외부 데이터 소스에 리액트에서 추구하는 동시성 처리를 해결하기 위한 훅이다

## useInsertionEffect

- CSS-in-js 라이브러리를 위한 훅이라고 생각하면 된다.
- 클라이언트 렌더링시에css의 추가 및 수정이 일어나지 않도록 서버 사이드에서 스타일 코드를 훅으로 잘 처리할 수 있게 도와준다.
- useEffect와 훅의 구조는 동일하지만 useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행된다.
- useLayoutEffect와 차이점은 DOM의 변경 작업이 다 끝난 이후에 실행되는 반면 useInsertionEffect는 이러한 DOM 변경 작업 이전에 실행된다.
- 이러한 차이는 브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 된다는 점에서 매우 크다.
- 라이브러리를 작성하는 경우가 아니라면 실제 애플리케이션 코드에 가급적 사용하지 말자

## 리액트의 엄격 모드

- 엄격 모드시 렌더링이 두번 되는 이유는 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이다.
- state,props,context가 변경되지 않으면(입력 값이 변경되지 않으면) 항상 동일한 JSX를(항상 같은 결과물) 반환해야 한다.

## 리액트 18의 엄격모드

- 리액트에서는 컴포넌트가 마운트 해제된 상태에서도 (컴포넌트가 렌더링 트리에 존재하지 않는 상태) 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정이다. (사용자가 뒤로가리를 했다가 다시 현재 화면으로 돌아왔을 경우 이전 상태 유지를 위해서)
- 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원한다. (개발모드에서만 적용)
- useEffect를 고의로 두 번 발생시킨다.

## Suspense

- 컴포넌트를 동적으로 가져올 수 있게 도와준다. (React.lazy?)

> <https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading>

### 리액트 18이전 Suspense의 문제점

- 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
- Suspense작업이 아직 진행중인데도 불구하고 useEffect가 실행이 됐다.
- 서버에서 사용할 수 없었다.
- SSR 구조에서 Suspense를 사용하려면 useMount와 같은 훅을 구현해서 반드시 클라이언트에서만 작동하도록 처리해야 했다.

### 리액트 18이후 Suspense

- effect가 빠르게 실행되는 문제가 수정됐다. 컴포넌트가 실제로 화면에 노출될 때 실행이 된다.
- 서버에서도 사용이 가능하다. (서버에서는 일단 fallback 상태의 트리를 클라이언트에 제공하고, 불러올 준비가 된다면 자연스럽게 렌더링한다.)
- 스로틀링 기능이 추가됐다. (화면이 너무 자주 업데이트 될 경우 시각적으로 방해받을 수 있기 때문에 다음 렌더링을 보여주기 전에 잠시 대기한다.)
- React.lazy를 사용해 컴포넌트를 지연시켜서 블러오거나, Next.js와 같이 Suspense를 자체적으로 지원하는 프레임워크에서만 Suspense를 사용하는 것이 가능하다.

# 중요한점

- react18의 동시성을 잘 다루는 법
- 이벤트 위임 방식
- suspense에 대하여
